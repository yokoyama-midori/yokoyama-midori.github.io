---
title: Cコンパイラを作る
date: 2025-9-11 10:00 0900
categories: [コンパイラ]
tags: [C]
math : true
---

Rui Ueyamaさんの[『低レイヤを知りたい人のためのCコンパイラ作成入門』](https://www.sigbus.info/compilerbook)と[『chibicc』のリファレンス実装](https://github.com/rui314/chibicc/tree/reference)を読みながらCコンパイラをCで作っていきます。セルフホストできるところまで進めるのが当面の目標です。日記形式で書いていきます。

## 9/2 ～ 9/10
「ステップ14: 関数の呼び出しに対応する」まで進めた。

## 9/11
[Commit aedbf56
](https://github.com/rui314/chibicc/commit/aedbf56c3af4914e3f183223ff879734683bec73#diff-629fe11334ae1d560032cdb6cc6f9a4fbb0f5b1365894b6b648d6ee4d5a654beR105-R106) では関数呼び出しの際RSPが16の倍数になるように条件分岐させている。僕の実装だと、mainのプロローグの際にRSPをローカル変数の分だけ引くことになるがそこを16の倍数になるようにしており、コード生成の際にはpushした分だけpopしてるはず。従ってこういうチェックをしなくても16の倍数に最初からなっている...はず。ここに関わらず僕の実装とchibiccの実装が異なっている箇所が色々ある。後々沼にハマることを考えるとなるべく同じロジックにしておきたい気もするがどうしようか？とりあえずこのコミットは無視して進めることにする。

引数なしの関数宣言を実装していく  
↑foo(){return 1;}bar(){return 2;}main(){return foo()+bar();}みたいなときに正しく16の倍数になっていない気がする。のでやっぱりcall前の16の倍数になるような調整をいれる。

もともとgenはreturnしたときに1つスタックにpushされているつもりだったが、それも難しそうな気がしてきたのでその前提でpopしてあるコードは消した。(そこに気づかずにwihleのデバッグが長引いた)chibiccを眺めながらなんとか完了。関数ごとにローカル変数を持っているので、別の関数が同じ変数名を持てる。ブロックのスコープには対応していない。

6個までの引数を持つ関数の宣言に対応  
入出力があれば簡単な競プロの問題が解けそうなコンパイラになってきた。ところでC言語って殆ど書いたことなかったけどC++に比べて全然機能がなくて驚かされる。

## 9/12,13
関数・仮引数・ローカル変数の宣言にintをつけるようにした  
`int`や`int*,int**`,...が扱える型を導入する。
`Type*` は各Nodeに持たせるがVarには持たせていない。  
`int main(){ int **a; *a; }`   
のような場合に`int **a`の型は`*`の個数ですぐに分かるが'*a'の型をどう決めるのかに悩む
`Var`に紐づけるべきな気がするな...

## 9/14
リファレンス実装を見ながらなんとか型の実装までやった。
`ND_EXPR_STMT`をリファレンス実装では随分前に導入していたがこのことに今日気づいた。
`ND_EXPR_STMT`のノードをコードにする際にはスタックにプッシュされた分RSPを戻す。
これにより実装がいくらか簡単になる。式の値を使わないような場合にこのノードを使う。
例えば`for(init;cond;inc)`については`cond`は結果を用いるから`ND_EXPR_STMT`は用いず、`init,inc`は結果を用いないから`ND_EXPR_STMT`を使う。`peek`関数を(リファレンス同様)実装した。これは次のトークンが与えられた文字列と一致するかどうかを返す関数だ。9cc/chibiccの特徴としてコードを最初に全部読み込んでメモリに載せること、トークナイズ・パース・コード生成を並列せずに順に行うということを著者が挙げていたと思うが、この関数が自然に実装できるのはこの特徴のおかげだと思う。

<iframe width="560" height="315" src="https://www.youtube.com/embed/MicEimqeNb4?si=1NY5dkufjdqaZYsc" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
などの動画を見た。

## 9/15
配列を実装した。配列からポインタへの暗黙の型変換が難しい。  
>配列に対して`sizeof`と単項`&`以外の演算子は定義されず暗黙のうちにポインタに変換される

`ND_DEREF,ND_VAR`ではコード生成の際、型が配列かどうかで挙動を変えている。配列でない場合、`gen_addr`でスタックにアドレスを積み、`load`でアドレスをpopしてアドレスが指す値をpushする。配列の場合、例えば`int a[2];`について`*a=1;`のコード生成では`gen_addr`に`*a`が渡される。ノードは`ND_DEREF`だから`gen`に`a`が渡される。次に`gen_addr`に`a`が渡され、スタックに`a`のアドレスが積まれる。そして`a`のアドレスに`1`が代入される。  
分かるような分からないような？とりあえず進めていく。

`sizeof`を実装した。chibiccに沿って実装している。compilerbookとは違ってまず`ND_SIZEOF`を設定しておき、`add_type`の際に`ND_NUM`の定数に置き換えを行っている。また`int`は8byteとしている。

グローバル変数に対応した。
よく言われることだけど、ローカル変数とグローバル変数が内部的にはかなり違う実装になっていて驚く。

## 9/16
`char`型を実装した。8byte以外のデータの最初の導入。  

文字列リテラルを実装した。`#include <stdio.h>`をコンパイルしたオブジェクトファイルとリンクすることで`printf`が使えるようになった。Cの文字列リテラルが変更できなくて、静的領域に置かれるというのを知ってびっくりした。

## 9/17
GNU拡張の式文を追加。エスケープ文字に対応。

## 9/19
コメントに対応した。  

ブロック文・関数のスコープに対応した。対応するchibiccのコミットではブロック文の方だけ実装している。
この実装はかなり簡単で驚いた。現在のスコープに対応する`VarList *scope`を持っておき、ブロックに入る際にその時点でのスコープを覚えておく。そしてブロック内でローカル変数の定義が現れるとスコープに追加し、ブロックから出る際には入る際のスコープに戻す。`find_var`は`scope`を前から探索するが、このリストは前のほうが新しく定義された変数、つまり深いところで定義された変数なのでこの方法で正しい。関数をパースする際には`scope`は`globals`にしておいた。  

テストをシェルスクリプトからCのコードに変えた。面倒だったのでテストコードはコピペ...。一瞬でテストが終わるようになった。`printf`を使いたいときは``#include <stdio.h>``だけを書いたファイルをGCCでコンパイルしておいて9ccでコンパイルしたアセンブリコードとリンクするようにしてたけど、そんなことしなくても勝手にlibcを見に行ってくれるらしい。というかstdio.hはただのヘッダファイルだからそもそも実装は書かれてないのか。競プロでは最終的に単一のコードに変換する関係で.hppファイルに実装を普段から書いていたけど、普通は宣言だけ書くんだよね。

TCFMを聞いていたがイランの核施設の遠心分離機をアメリカ側がUSB経由のマルウェアを使って物理的に破壊したという話が面白かった
<iframe class="hatenablogcard" style="width:100%;height:155px;max-width:680px" src="https://hatenablog-parts.com/embed?url=https://ja.wikipedia.org/wiki/%E3%82%B9%E3%82%BF%E3%83%83%E3%82%AF%E3%82%B9%E3%83%8D%E3%83%83%E3%83%88" width="300" height="150" frameborder="0" scrolling="no"></iframe>

## 9/20
`struct`に対応した。C++では
```cpp 
struct Name {
    /* ... */
}; 
```
という形でグローバルにしかほとんど使ったことがなかったので、ローカルにも定義できることや無名の`struct`が作れることを知らなかった。入れ子に定義するのはSplay木を書いたときに使ったことがあったな。ここでは
```c
struct {
    /* ... */
} x; 
```
という形の無名の`struct`にしか対応していない。

## 9/21
アラインメントを調整した。リファレンス実装だと2つのcommitで1つの意味のある修正になっていると思う。  
struct tagの追加

## 9/24
`->`opを追加した。構造体のタグを追加した。

## 9/28
コンパイラーブックの『Cの型の構文』の章を読んだ。signal関数の宣言なかなかやばい。
```c
void (*signal(int, void (*)(int)))(int);
```

## 10/1
`typedef`を実装した
テストには
```cpp
typedef int t;
t t = 1;
```
というコードがある。このままだとgccやclangでコンパイルは通らないが
```cpp
typedef int t;
{ t t = 1; }
```
のようにするとコンパイル出来てしまうらしい。

## 10/2
`sizeof(int)`を8から4にした。
`short`,`long`を追加した。

## 10/5
ネストされた型宣言に対応。　
[演算子の優先順位](https://learn.microsoft.com/ja-jp/cpp/c-language/precedence-and-order-of-evaluation?view=msvc-170)を確認した。
大まかに言って型の読み方としては `pre (mid) suf`という型宣言があった場合、Goの(理解しやすい)記法では`mid suf pre`の順となる。例えば`int (*x)[3]`の場合`var x *[3]int`となる。すなわち`x`はポインタであり、そのベースは長さ3の配列であり、そのベースは`int`である。コードの並びとデータの並びが一致していないのでややこしい。chibiccでの実装の一部

```c
// declarator = "*"* ("(" declarator ")" | ident) type-suffix
Type *declarator(Type *ty, char **name) {
  while (consume("*"))
    ty = pointer_to(ty);

  if (consume("(")) {
    Type *placeholder = calloc(1, sizeof(Type));
    Type *new_ty = declarator(placeholder, name);
    expect(")");
    *placeholder = *type_suffix(ty);
    return new_ty;
  }

  *name = expect_ident();
  return type_suffix(ty);
}
```

がぱっと見分からなかったが、例を考えるとなんとか理解できた。括弧の外側の情報を内側へ伝えるために引数を取っている。

## 10/17
しばらく開いてしまった。
関数の返り値に型を追加した。`void`型を追加した。chibiccではまだ関数の返り値の型としては使えないようだがこれも使えるようにしておいた。

## 10/19
`_Bool`を追加した。

## 10/23
`sizeof`に型を渡せるようにした。e.g. `sizeof(int(*)[4])`  
unaryを渡すときと違って、こちらは括弧必須らしい。long型の数値リテラルに対応した。

## 10/24
型のキャストに対応した。chibiccではテストコード内に`bool`が現れるが、これは`_Bool`が正しい気がする。
コンパイラが`bool`を認識している様子がない気がするけどテスト通るのかな？ところでCはC23から`bool`を(ヘッダ`stdbool.h`をインクルードせずに)使えるようになったらしい。  
文字リテラルに対応した。  
関数の返り値を型のサイズに正しく切り捨てるようにした。`void`型のサイズは取得できないようにしているので、`void`の場合は何もしないように分岐させた。  
関数宣言に対応した。

# 11/5
`enum`に対応した。`enum`って競プロだと赤黒木の`RED,BLACK`で使ってる実装くらいでしか見たことないな。

## 11/6
`static`ローカル変数に対応した。スコープについて少し考えていたが、`static`がつくかつかないかでスコープは特に変わらないので必要なかった。グローバル変数にさえすれば良い。  
`for`文の初期化式での変数宣言に対応

## 11/15
`++`,`--`演算子に対応した。  
`+=`,`-=`,`*=`,`/=`に対応した。  
`!`演算子に対応した。返り値は`int`型。C++だと`bool`型で返すらしい。  
`~`演算子に対応した。返り値の型を元の型と同じにしているがこれが正しいのかはちゃんと調べてない。4byteより小さい型は4byteになっているような気がする。

## 11/16
ビット単位演算`&`,`|`,`^`に対応した。レファレンスに合わせて`int`型を返すようにしている。  
論理演算`&&`,`||`に対応した。レファレンスではジャンプ命令を使っているが、ここではオペランドを0/1に変換してから単にand,or命令を使った。

## 11/19
関数の引数におけるarray-to-pointerの変換に対応した。これは

```c
int f(int x[][2][3]);
int g(int x[1][2][3]);
```

のようなコードをコンパイラが

```c
int f(int (*x)[2][3]);
int g(int (*x)[2][3]);
```

のように認識するというもの。引数にsizeofの結果が大きなものを渡したくないことを考えればこういう仕様があるのは理解できる気がする。

## 11/20
不完全な構造体の型に対応した。不完全というのは大きさを確定するための情報を欠いているという意味。`struct tag *t;`のようなコードがそれに当たる。`t`のサイズは決まっているが`struct tag`のサイズはここでは決まらない。
次のコード
```c
struct T {
  int a;
};
{
  struct T *t;
  struct T {
    int b;
  };
  t = calloc(1, sizeof(struct T));
  t->a = 0;
}
```
で`struct T *t;`の部分の解釈が最初の3行が有るか無いかで変わり、無かった場合`t`のメンバ変数は`b`になる。ここらへんややこしい。

## 11/24
break文に対応した。for/while文の終わりのラベルに飛ぶだけだが、ラベル名を知る必要があり対応する数を記憶するグローバル変数を用意している。
通常break文がどのループを抜けるのかは明らかだが、次の例では明らかではない。

```c
while(1) {
  while( ({break;1;}) ) {
  }
}
```
外側のループを抜ける場合は通過するだけだが、内側のwhile文を抜ける場合無限ループになる。`Clang`でコンパイルすると
```terminal
a.c:3:13: warning: 'break' is bound to current loop, GCC binds it to the enclosing loop [-Wgcc-compat]
    3 |     while( ({break;1;}) ) {
      |             ^
1 warning generated.
```
という警告が出る。`Clang`は内側のwhile文を抜け、`GCC`は外側のwhile文を抜けるようだ。ここでは`Clang`の挙動に合わせた。
