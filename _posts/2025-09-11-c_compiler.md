---
title: Cコンパイラを作る
date: 2025-9-11 10:00 0900
categories: [コンパイラ]
tags: [C]
math : true
---

Rui Ueyamaさんの[『低レイヤを知りたい人のためのCコンパイラ作成入門』](https://www.sigbus.info/compilerbook)と[『chibicc』のリファレンス実装](https://github.com/rui314/chibicc/tree/reference)を読みながらCコンパイラをCで作っていきます。セルフホストできるところまで進めるのが当面の目標です。日記形式で書いていきます。

### 9/2 ～ 9/10
「ステップ14: 関数の呼び出しに対応する」まで進めた。

### 9/11
[Commit aedbf56
](https://github.com/rui314/chibicc/commit/aedbf56c3af4914e3f183223ff879734683bec73#diff-629fe11334ae1d560032cdb6cc6f9a4fbb0f5b1365894b6b648d6ee4d5a654beR105-R106) では関数呼び出しの際RSPが16の倍数になるように条件分岐させている。僕の実装だと、mainのプロローグの際にRSPをローカル変数の分だけ引くことになるがそこを16の倍数になるようにしており、コード生成の際にはpushした分だけpopしてるはず。従ってこういうチェックをしなくても16の倍数に最初からなっている...はず。ここに関わらず僕の実装とchibiccの実装が異なっている箇所が色々ある。後々沼にハマることを考えるとなるべく同じロジックにしておきたい気もするがどうしようか？とりあえずこのコミットは無視して進めることにする。

引数なしの関数宣言を実装していく  
↑foo(){return 1;}bar(){return 2;}main(){return foo()+bar();}みたいなときに正しく16の倍数になっていない気がする。のでやっぱりcall前の16の倍数になるような調整をいれる。

もともとgenはreturnしたときに1つスタックにpushされているつもりだったが、それも難しそうな気がしてきたのでその前提でpopしてあるコードは消した。(そこに気づかずにwihleのデバッグが長引いた)chibiccを眺めながらなんとか完了。関数ごとにローカル変数を持っているので、別の関数が同じ変数名を持てる。ブロックのスコープには対応していない。

6個までの引数を持つ関数の宣言に対応  
入出力があれば簡単な競プロの問題が解けそうなコンパイラになってきた。ところでC言語って殆ど書いたことなかったけどC++に比べて全然機能がなくて驚かされる。

### 9/12,13
関数・仮引数・ローカル変数の宣言にintをつけるようにした  
`int`や`int*,int**`,...が扱える型を導入する。
`Type*` は各Nodeに持たせるがVarには持たせていない。  
`int main(){ int **a; *a; }`   
のような場合に`int **a`の型は`*`の個数ですぐに分かるが'*a'の型をどう決めるのかに悩む
`Var`に紐づけるべきな気がするな...

### 9/14
リファレンス実装を見ながらなんとか型の実装までやった。
`ND_EXPR_STMT`をリファレンス実装では随分前に導入していたがこのことに今日気づいた。
`ND_EXPR_STMT`のノードをコードにする際にはスタックにプッシュされた分RSPを戻す。
これにより実装がいくらか簡単になる。式の値を使わないような場合にこのノードを使う。
例えば`for(init;cond;inc)`については`cond`は結果を用いるから`ND_EXPR_STMT`は用いず、`init,inc`は結果を用いないから`ND_EXPR_STMT`を使う。`peek`関数を(リファレンス同様)実装した。これは次のトークンが与えられた文字列と一致するかどうかを返す関数だ。9cc/chibiccの特徴としてコードを最初に全部読み込んでメモリに載せること、トークナイズ・パース・コード生成を並列せずに順に行うということを著者が挙げていたと思うが、この関数が自然に実装できるのはこの特徴のおかげだと思う。

<iframe width="560" height="315" src="https://www.youtube.com/embed/MicEimqeNb4?si=1NY5dkufjdqaZYsc" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
などの動画を見た。

### 9/15
配列を実装した。配列からポインタへの暗黙の型変換が難しい。  
>配列に対して`sizeof`と単項`&`以外の演算子は定義されず暗黙のうちにポインタに変換される

`ND_DEREF,ND_VAR`ではコード生成の際、型が配列かどうかで挙動を変えている。配列でない場合、`gen_addr`でスタックにアドレスを積み、`load`でアドレスをpopしてアドレスが指す値をpushする。配列の場合、例えば`int a[2];`について`*a=1;`のコード生成では`gen_addr`に`*a`が渡される。ノードは`ND_DEREF`だから`gen`に`a`が渡される。次に`gen_addr`に`a`が渡され、スタックに`a`のアドレスが積まれる。そして`a`のアドレスに`1`が代入される。  
分かるような分からないような？とりあえず進めていく。

`sizeof`を実装した。chibiccに沿って実装している。compilerbookとは違ってまず`ND_SIZEOF`を設定しておき、`add_type`の際に`ND_NUM`の定数に置き換えを行っている。また`int`は8byteとしている。

グローバル変数に対応した。
よく言われることだけど、ローカル変数とグローバル変数が内部的にはかなり違う実装になっていて驚く。

### 9/16
`char`型を実装した。8byte以外のデータの最初の導入。  

文字列リテラルを実装した。`#include <stdio.h>`をコンパイルしたオブジェクトファイルとリンクすることで`printf`が使えるようになった。Cの文字列リテラルが変更できなくて、静的領域に置かれるというのを知ってびっくりした。

## 9/17
GNU拡張の式文を追加。エスケープ文字に対応。

## 9/19
コメントに対応した。  

ブロック文・関数のスコープに対応した。対応するchibiccのコミットではブロック文の方だけ実装している。
この実装はかなり簡単で驚いた。現在のスコープに対応する`VarList *scope`を持っておき、ブロックに入る際にその時点でのスコープを覚えておく。そしてブロック内でローカル変数の定義が現れるとスコープに追加し、ブロックから出る際には入る際のスコープに戻す。`find_var`は`scope`を前から探索するが、このリストは前のほうが新しく定義された変数、つまり深いところで定義された変数なのでこの方法で正しい。関数をパースする際には`scope`は`globals`にしておいた。  

テストをシェルスクリプトからCのコードに変えた。面倒だったのでテストコードはコピペ...。一瞬でテストが終わるようになった。`printf`を使いたいときは``#include <stdio.h>``だけを書いたファイルをGCCでコンパイルしておいて9ccでコンパイルしたアセンブリコードとリンクするようにしてたけど、そんなことしなくても勝手にlibcを見に行ってくれるらしい。というかstdio.hはただのヘッダファイルだからそもそも実装は書かれてないのか。競プロでは最終的に単一のコードに変換する関係で.hppファイルに実装を普段から書いていたけど、普通は宣言だけ書くんだよね。

TCFMを聞いていたがイランの核施設の遠心分離機をアメリカ側がUSB経由のマルウェアを使って物理的に破壊したという話が面白かった
<iframe class="hatenablogcard" style="width:100%;height:155px;max-width:680px" src="https://hatenablog-parts.com/embed?url=https://ja.wikipedia.org/wiki/%E3%82%B9%E3%82%BF%E3%83%83%E3%82%AF%E3%82%B9%E3%83%8D%E3%83%83%E3%83%88" width="300" height="150" frameborder="0" scrolling="no"></iframe>
